import { formatters } from 'web3-core-helpers';
import { Accounts } from 'web3-eth-accounts';
import { Ens } from 'web3-eth-ens';
import { ContractModuleFactory } from 'web3-eth-contract';
import { Personal } from 'web3-eth-personal';
import { AbiCoder } from 'web3-eth-abi';
import { Iban } from 'web3-eth-iban';
import { Network } from 'web3-net';
import * as Utils from 'web3-utils';
import Nat from 'eth-lib/lib/nat';
import Bytes from 'eth-lib/lib/bytes';
import Hash from 'eth-lib/lib/hash';
import RLP from 'eth-lib/lib/rlp';
import Account from 'eth-lib/lib/account';
import isString from 'lodash/isString';
import { LogSubscription, NewHeadsSubscription, NewPendingTransactionsSubscription, SyncingSubscription } from 'web3-core-subscriptions';
import { AbstractGetBlockMethod, AbstractGetUncleMethod, AbstractGetBlockTransactionCountMethod, AbstractGetBlockUncleCountMethod, AbstractGetTransactionFromBlockMethod, SignTransactionMethod, SignMethod, AbstractMethodFactory, CallMethod, ChainIdMethod, EstimateGasMethod, GetAccountsMethod, GetBalanceMethod, GetBlockNumberMethod, GetCodeMethod, GetCoinbaseMethod, GetGasPriceMethod, GetHashrateMethod, GetNodeInfoMethod, GetPastLogsMethod, GetProtocolVersionMethod, GetStorageAtMethod, GetTransactionCountMethod, GetTransactionMethod, GetTransactionReceiptMethod, GetWorkMethod, IsMiningMethod, IsSyncingMethod, RequestAccountsMethod, SubmitWorkMethod, VersionMethod, SendRawTransactionMethod, EthSendTransactionMethod } from 'web3-core-method';
import { ProviderResolver } from 'web3-providers';
import { AbstractWeb3Module } from 'web3-core';

class TransactionSigner {
  constructor(utils, formatters$$1) {
    this.utils = utils;
    this.formatters = formatters$$1;
  }
  async sign(transaction, privateKey) {
    if (!privateKey) {
      throw new Error('No privateKey given to the TransactionSigner.');
    }
    if (privateKey.startsWith('0x')) {
      privateKey = privateKey.substring(2);
    }
    transaction = this.formatters.txInputFormatter(transaction);
    transaction.to = transaction.to || '0x';
    transaction.data = transaction.data || '0x';
    transaction.value = transaction.value || '0x';
    transaction.chainId = this.utils.numberToHex(transaction.chainId);
    const rlpEncoded = this.createRlpEncodedTransaction(transaction);
    const hash = Hash.keccak256(rlpEncoded);
    const signature = this.createAccountSignature(hash, privateKey, transaction.chainId);
    const rawTransaction = RLP.encode(this.mapRlpEncodedTransaction(rlpEncoded, signature));
    const values = RLP.decode(rawTransaction);
    return {
      messageHash: hash,
      v: this.trimLeadingZero(values[6]),
      r: this.trimLeadingZero(values[7]),
      s: this.trimLeadingZero(values[8]),
      rawTransaction
    };
  }
  createRlpEncodedTransaction(transaction) {
    return RLP.encode([Bytes.fromNat(transaction.nonce), Bytes.fromNat(transaction.gasPrice), Bytes.fromNat(transaction.gas), transaction.to.toLowerCase(), Bytes.fromNat(transaction.value), transaction.data, Bytes.fromNat(transaction.chainId), '0x', '0x']);
  }
  createAccountSignature(hash, privateKey, chainId) {
    return Account.makeSigner(Nat.toNumber(chainId) * 2 + 35)(hash, privateKey);
  }
  mapRlpEncodedTransaction(rlpEncoded, signature) {
    const rawTransaction = RLP.decode(rlpEncoded).slice(0, 6).concat(Account.decodeSignature(signature));
    rawTransaction[6] = this.makeEven(this.trimLeadingZero(rawTransaction[6]));
    rawTransaction[7] = this.makeEven(this.trimLeadingZero(rawTransaction[7]));
    rawTransaction[8] = this.makeEven(this.trimLeadingZero(rawTransaction[8]));
    return rawTransaction;
  }
  trimLeadingZero(hex) {
    while (hex && hex.startsWith('0x0')) {
      hex = `0x${hex.slice(3)}`;
    }
    return hex;
  }
  makeEven(hex) {
    if (hex.length % 2 === 1) {
      hex = hex.replace('0x', '0x0');
    }
    return hex;
  }
}

class GetBlockMethod extends AbstractGetBlockMethod {
  constructor(utils, formatters$$1, moduleInstance) {
    super('eth_getBlockByNumber', utils, formatters$$1, moduleInstance);
  }
  beforeExecution(moduleInstance) {
    if (this.isHash(this.parameters[0])) {
      this.rpcMethod = 'eth_getBlockByHash';
    }
    super.beforeExecution(moduleInstance);
  }
}

class GetUncleMethod extends AbstractGetUncleMethod {
  constructor(utils, formatters$$1, moduleInstance) {
    super('eth_getUncleByBlockNumberAndIndex', utils, formatters$$1, moduleInstance);
  }
  beforeExecution(moduleInstance) {
    if (this.isHash(this.parameters[0])) {
      this.rpcMethod = 'eth_getUncleByBlockHashAndIndex';
    }
    super.beforeExecution(moduleInstance);
  }
}

class GetBlockTransactionCountMethod extends AbstractGetBlockTransactionCountMethod {
  constructor(utils, formatters$$1, moduleInstance) {
    super('eth_getBlockTransactionCountByNumber', utils, formatters$$1, moduleInstance);
  }
  beforeExecution(moduleInstance) {
    if (this.isHash(this.parameters[0])) {
      this.rpcMethod = 'eth_getBlockTransactionCountByHash';
    }
    super.beforeExecution(moduleInstance);
  }
}

class GetBlockUncleCountMethod extends AbstractGetBlockUncleCountMethod {
  constructor(utils, formatters$$1, moduleInstance) {
    super('eth_getUncleCountByBlockNumber', utils, formatters$$1, moduleInstance);
  }
  beforeExecution(moduleInstance) {
    if (this.isHash(this.parameters[0])) {
      this.rpcMethod = 'eth_getUncleCountByBlockHash';
    }
    super.beforeExecution(moduleInstance);
  }
}

class GetTransactionFromBlockMethod extends AbstractGetTransactionFromBlockMethod {
  constructor(utils, formatters$$1, moduleInstance) {
    super('eth_getTransactionByBlockNumberAndIndex', utils, formatters$$1, moduleInstance);
  }
  beforeExecution(moduleInstance) {
    if (this.isHash(this.parameters[0])) {
      this.rpcMethod = 'eth_getTransactionByBlockHashAndIndex';
    }
    super.beforeExecution(moduleInstance);
  }
}

class EthSignTransactionMethod extends SignTransactionMethod {
  constructor(utils, formatters$$1, moduleInstance) {
    super(utils, formatters$$1, moduleInstance);
  }
  beforeExecution(moduleInstance) {
    this.parameters[0] = this.formatters.inputTransactionFormatter(this.parameters[0], moduleInstance);
  }
  execute() {
    if (isString(this.parameters[1])) {
      const account = this.moduleInstance.accounts.wallet[this.parameters[1]];
      if (account) {
        return this.moduleInstance.transactionSigner.sign(this.parameters[0], account.privateKey);
      }
    }
    return super.execute();
  }
}

class EthSignMethod extends SignMethod {
  constructor(utils, formatters$$1, moduleInstance) {
    super(utils, formatters$$1, moduleInstance);
  }
  execute() {
    if (this.moduleInstance.accounts.wallet[this.parameters[1]]) {
      return this.signLocally();
    }
    return super.execute();
  }
  async signLocally() {
    try {
      this.beforeExecution(this.moduleInstance);
      let signedMessage = this.moduleInstance.accounts.sign(this.parameters[0], this.moduleInstance.accounts.wallet[this.parameters[1]].address);
      if (this.callback) {
        this.callback(false, signedMessage);
      }
      return signedMessage;
    } catch (error) {
      if (this.callback) {
        this.callback(error, null);
      }
      throw error;
    }
  }
}

class MethodFactory extends AbstractMethodFactory {
  constructor(utils, formatters$$1) {
    super(utils, formatters$$1);
    this.methods = {
      getNodeInfo: GetNodeInfoMethod,
      getProtocolVersion: GetProtocolVersionMethod,
      getCoinbase: GetCoinbaseMethod,
      isMining: IsMiningMethod,
      getHashrate: GetHashrateMethod,
      isSyncing: IsSyncingMethod,
      getGasPrice: GetGasPriceMethod,
      getAccounts: GetAccountsMethod,
      getBlockNumber: GetBlockNumberMethod,
      getBalance: GetBalanceMethod,
      getStorageAt: GetStorageAtMethod,
      getCode: GetCodeMethod,
      getBlock: GetBlockMethod,
      getUncle: GetUncleMethod,
      getBlockTransactionCount: GetBlockTransactionCountMethod,
      getBlockUncleCount: GetBlockUncleCountMethod,
      getTransaction: GetTransactionMethod,
      getTransactionFromBlock: GetTransactionFromBlockMethod,
      getTransactionReceipt: GetTransactionReceiptMethod,
      getTransactionCount: GetTransactionCountMethod,
      sendSignedTransaction: SendRawTransactionMethod,
      signTransaction: EthSignTransactionMethod,
      sendTransaction: EthSendTransactionMethod,
      sign: EthSignMethod,
      call: CallMethod,
      estimateGas: EstimateGasMethod,
      submitWork: SubmitWorkMethod,
      getWork: GetWorkMethod,
      getPastLogs: GetPastLogsMethod,
      requestAccounts: RequestAccountsMethod,
      getId: VersionMethod,
      getChainId: ChainIdMethod
    };
  }
}

class SubscriptionsFactory {
  constructor(utils, formatters$$1) {
    this.utils = utils;
    this.formatters = formatters$$1;
  }
  getSubscription(moduleInstance, type, options) {
    switch (type) {
      case 'logs':
        return new LogSubscription(options, this.utils, this.formatters, moduleInstance, new GetPastLogsMethod(this.utils, this.formatters));
      case 'newBlockHeaders':
        return new NewHeadsSubscription(this.utils, this.formatters, moduleInstance);
      case 'pendingTransactions':
        return new NewPendingTransactionsSubscription(this.utils, this.formatters, moduleInstance);
      case 'syncing':
        return new SyncingSubscription(this.utils, this.formatters, moduleInstance);
      default:
        throw new Error(`Unknown subscription: ${type}`);
    }
  }
}

class Eth extends AbstractWeb3Module {
  constructor(provider, methodFactory, net, accounts, personal, Iban$$1, abiCoder, ens, utils, formatters$$1, subscriptionsFactory, contractModuleFactory, options, nodeNet) {
    super(provider, options, methodFactory, nodeNet);
    this.net = net;
    this.accounts = accounts;
    this.personal = personal;
    this.Iban = Iban$$1;
    this.abi = abiCoder;
    this.ens = ens;
    this.utils = utils;
    this.formatters = formatters$$1;
    this.subscriptionsFactory = subscriptionsFactory;
    this.contractModuleFactory = contractModuleFactory;
    this.initiatedContracts = [];
    this._transactionSigner = options.transactionSigner;
    this.Contract = (abi, address, options = {}) => {
      const contract = this.contractModuleFactory.createContract(this.currentProvider, this.accounts, abi, address, {
        defaultAccount: options.from || options.defaultAccount || this.defaultAccount,
        defaultBlock: options.defaultBlock || this.defaultBlock,
        defaultGas: options.gas || options.defaultGas || this.defaultGas,
        defaultGasPrice: options.gasPrice || options.defaultGasPrice || this.defaultGasPrice,
        transactionBlockTimeout: options.transactionBlockTimeout || this.transactionBlockTimeout,
        transactionConfirmationBlocks: options.transactionConfirmationBlocks || this.transactionConfirmationBlocks,
        transactionPollingTimeout: options.transactionPollingTimeout || this.transactionPollingTimeout,
        transactionSigner: this.transactionSigner,
        data: options.data
      });
      this.initiatedContracts.push(contract);
      return contract;
    };
  }
  get transactionSigner() {
    return this._transactionSigner;
  }
  set transactionSigner(transactionSigner) {
    this._transactionSigner = transactionSigner;
    this.accounts.transactionSigner = transactionSigner;
    this.ens.transactionSigner = transactionSigner;
    this.initiatedContracts.forEach(contract => {
      contract.transactionSigner = transactionSigner;
    });
  }
  clearSubscriptions() {
    return super.clearSubscriptions('eth_unsubscribe');
  }
  set defaultGasPrice(value) {
    this.initiatedContracts.forEach(contract => {
      contract.defaultGasPrice = value;
    });
    this.net.defaultGasPrice = value;
    this.personal.defaultGasPrice = value;
    super.defaultGasPrice = value;
  }
  get defaultGasPrice() {
    return super.defaultGasPrice;
  }
  set defaultGas(value) {
    this.initiatedContracts.forEach(contract => {
      contract.defaultGas = value;
    });
    this.net.defaultGas = value;
    this.personal.defaultGas = value;
    super.defaultGas = value;
  }
  get defaultGas() {
    return super.defaultGas;
  }
  set transactionBlockTimeout(value) {
    this.initiatedContracts.forEach(contract => {
      contract.transactionBlockTimeout = value;
    });
    this.net.transactionBlockTimeout = value;
    this.personal.transactionBlockTimeout = value;
    super.transactionBlockTimeout = value;
  }
  get transactionBlockTimeout() {
    return super.transactionBlockTimeout;
  }
  set transactionConfirmationBlocks(value) {
    this.initiatedContracts.forEach(contract => {
      contract.transactionConfirmationBlocks = value;
    });
    this.net.transactionConfirmationBlocks = value;
    this.personal.transactionConfirmationBlocks = value;
    super.transactionConfirmationBlocks = value;
  }
  get transactionConfirmationBlocks() {
    return super.transactionConfirmationBlocks;
  }
  set transactionPollingTimeout(value) {
    this.initiatedContracts.forEach(contract => {
      contract.transactionPollingTimeout = value;
    });
    this.net.transactionPollingTimeout = value;
    this.personal.transactionPollingTimeout = value;
    super.transactionPollingTimeout = value;
  }
  get transactionPollingTimeout() {
    return super.transactionPollingTimeout;
  }
  set defaultAccount(value) {
    this.initiatedContracts.forEach(contract => {
      contract.defaultAccount = this.utils.toChecksumAddress(value);
    });
    this.net.defaultAccount = value;
    this.personal.defaultAccount = value;
    super.defaultAccount = value;
  }
  get defaultAccount() {
    return super.defaultAccount;
  }
  set defaultBlock(value) {
    this.initiatedContracts.forEach(contract => {
      contract.defaultBlock = value;
    });
    this.net.defaultBlock = value;
    this.personal.defaultBlock = value;
    super.defaultBlock = value;
  }
  get defaultBlock() {
    return super.defaultBlock;
  }
  subscribe(type, options, callback) {
    return this.subscriptionsFactory.getSubscription(this, type, options).subscribe(callback);
  }
  setProvider(provider, net) {
    const setContractProviders = this.initiatedContracts.every(contract => {
      return contract.setProvider(provider, net);
    });
    return this.net.setProvider(provider, net) && this.personal.setProvider(provider, net) && super.setProvider(provider, net) && setContractProviders;
  }
}

function TransactionSigner$1() {
  return new TransactionSigner(Utils, formatters);
}
function Eth$1(provider, net = null, options = {}) {
  if (!options.transactionSigner) {
    options.transactionSigner = new TransactionSigner$1();
  }
  const resolvedProvider = new ProviderResolver().resolve(provider, net);
  const accounts = new Accounts(resolvedProvider, null, options);
  const abiCoder = new AbiCoder();
  return new Eth(resolvedProvider, new MethodFactory(Utils, formatters), new Network(resolvedProvider, null, options), accounts, new Personal(resolvedProvider, null, accounts, options), Iban, abiCoder, new Ens(resolvedProvider, null, accounts, options), Utils, formatters, new SubscriptionsFactory(Utils, formatters), new ContractModuleFactory(Utils, formatters, abiCoder, accounts), options, net);
}

export { TransactionSigner$1 as TransactionSigner, Eth$1 as Eth };
